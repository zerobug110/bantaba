"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.defaultProps = void 0;

var React = _interopRequireWildcard(require("react"));

var _inlineStylePrefixer = _interopRequireDefault(require("inline-style-prefixer"));

var _reactTransitionContext = require("react-transition-context");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const fillStyle = {
  position: 'absolute',
  top: 0,
  left: 0,
  right: 0,
  bottom: 0
};
const baseViewStyle = {
  display: 'inline-block',
  verticalAlign: 'top',
  whiteSpace: 'normal',
  width: '100%'
};
const defaultProps = {
  animateHeight: true,
  transitionDuration: 500,
  transitionTimingFunction: 'ease',
  keepViewsMounted: false,
  prefixer: new _inlineStylePrefixer.default(),
  style: {},
  viewportStyle: {},
  rtl: false,
  spacing: 1
};
exports.defaultProps = defaultProps;

function applyDefaults(props) {
  const result = _objectSpread({}, props);

  for (const key in defaultProps) {
    if (defaultProps.hasOwnProperty(key) && props[key] == null) {
      result[key] = defaultProps[key];
    }
  }

  return result;
}

class ViewSlider extends React.Component {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "state", {
      height: undefined,
      transitioning: false,
      activeView: this.props.activeView,
      numViews: this.props.numViews,
      // this is used to determine the correct transitionState for the previous active view.
      prevActiveView: null
    });

    _defineProperty(this, "views", []);

    _defineProperty(this, "timeouts", {});

    _defineProperty(this, "lastProps", this.props);

    _defineProperty(this, "getDefaultedProps", () => {
      if (this.lastProps !== this.props || !this.lastDefaultedProps) {
        this.lastProps = this.props;
        this.lastDefaultedProps = applyDefaults(this.props);
      }

      return this.lastDefaultedProps;
    });

    _defineProperty(this, "measureHeight", node => {
      if (!node) return null;
      return node.clientHeight;
    });

    _defineProperty(this, "onTransitionEnd", event => {
      // ignore transitionend events from deeper components
      if (event && event.target !== this.viewport) return; // phase 0: unset height and disable transitions

      this.setState({
        height: undefined,
        numViews: this.props.numViews,
        prevActiveView: null,
        transitioning: false
      }, () => {
        const {
          onSlideTransitionEnd
        } = this.props;
        if (onSlideTransitionEnd) onSlideTransitionEnd();
      });
    });

    _defineProperty(this, "getTransitionState", childIndex => {
      const {
        activeView,
        prevActiveView
      } = this.state;
      if (prevActiveView == null) return childIndex === activeView ? 'in' : 'out';
      if (childIndex === activeView) return 'entering';
      if (childIndex === prevActiveView) return 'leaving';
      return 'out';
    });

    _defineProperty(this, "renderView", index => {
      const {
        fillParent,
        prefixer,
        keepViewsMounted,
        spacing,
        rtl,
        viewStyle,
        innerViewWrapperStyle
      } = this.getDefaultedProps();
      const {
        activeView,
        transitioning
      } = this.state;

      const style = _objectSpread({}, baseViewStyle, viewStyle);

      if (fillParent) {
        Object.assign(style, fillStyle);
        style.overflow = 'auto';
        if (rtl) style.right = `${index * spacing * 100}%`;else style.left = `${index * spacing * 100}%`;
      } else if (index > 0) {
        if (rtl) style.marginRight = `${(spacing - 1) * 100}%`;else style.marginLeft = `${(spacing - 1) * 100}%`;
      } // when not transitioning, render empty placeholder divs before the active view to push it into the right
      // horizontal position


      if (!transitioning && activeView !== index && !keepViewsMounted) {
        return React.createElement("div", {
          key: index,
          style: prefixer.prefix(style)
        });
      }

      return React.createElement("div", {
        key: index,
        style: prefixer.prefix(style),
        ref: c => this.views[index] = c
      }, React.createElement("div", {
        style: prefixer.prefix(_objectSpread({
          width: '100%'
        }, innerViewWrapperStyle))
      }, React.createElement(_reactTransitionContext.TransitionContext, {
        state: this.getTransitionState(index)
      }, this.props.renderView({
        index,
        active: index === activeView,
        transitionState: this.getTransitionState(index)
      }))));
    });

    _defineProperty(this, "animateHeight", () => {
      const {
        animateHeight,
        fillParent,
        keepViewsMounted
      } = this.getDefaultedProps();
      return animateHeight && !fillParent && !keepViewsMounted;
    });

    _defineProperty(this, "rootRef", node => {
      this.root = node;
      const {
        rootRef
      } = this.getDefaultedProps();
      if (rootRef) rootRef(node);
    });

    _defineProperty(this, "viewportRef", node => {
      this.viewport = node;
      const {
        viewportRef
      } = this.getDefaultedProps();
      if (viewportRef) viewportRef(node);
    });
  }

  setTimeout(name, callback, delay) {
    if (this.timeouts[name]) clearTimeout(this.timeouts[name]);
    this.timeouts[name] = setTimeout(callback, delay);
  }

  componentDidUpdate() {
    const {
      activeView,
      transitionDuration,
      keepViewsMounted
    } = this.getDefaultedProps();
    let newState;

    if (activeView !== this.state.activeView && this.state.height === undefined) {
      if (keepViewsMounted) {
        // scroll all views except the current back to the top
        for (let i = 0; i < this.views.length; i++) {
          if (i === this.state.activeView) continue;
          if (this.views[i]) this.views[i].scrollTop = 0;
        }
      } // phase 1: set current height


      newState = {
        height: this.measureHeight(this.views[this.state.activeView])
      };
    } else if (this.state.height !== undefined && !this.state.transitioning) {
      // phase 2: enable transitions
      newState = {
        transitioning: true
      };
    } else if (activeView !== this.state.activeView) {
      // phase 3: change height/activeView
      newState = {
        activeView,
        numViews: Math.max(this.state.numViews, activeView + 1),
        prevActiveView: this.state.activeView,
        height: this.measureHeight(this.views[activeView])
      };
    }

    const finalNewState = newState;
    if (!finalNewState) return;
    this.setState(finalNewState, () => {
      if (finalNewState.activeView != null) {
        this.setTimeout('onTransitionEnd', this.onTransitionEnd, transitionDuration);
      }
    });
  }

  componentWillUnmount() {
    for (let name in this.timeouts) clearTimeout(this.timeouts[name]);
  }

  render() {
    const {
      style,
      className,
      viewportClassName,
      viewportStyle,
      prefixer,
      fillParent,
      transitionDuration,
      transitionTimingFunction,
      keepViewsMounted,
      rtl,
      spacing
    } = this.getDefaultedProps();
    const animateHeight = this.animateHeight();
    const {
      activeView,
      numViews,
      height,
      transitioning
    } = this.state;

    const finalOuterStyle = _objectSpread({
      transitionProperty: 'height',
      transitionDuration: `${transitionDuration}ms`,
      transitionTimingFunction,
      overflow: 'hidden',
      height: animateHeight && height != null ? height : undefined
    }, style);

    const finalViewportStyle = _objectSpread({
      position: 'relative',
      transform: `translateX(calc(${activeView * spacing * (rtl ? 100 : -100)}% + 0px))`,
      whiteSpace: 'nowrap',
      minHeight: '100%',
      direction: rtl ? 'rtl' : 'ltr',
      transition: transitioning ? `transform ${transitionTimingFunction} ${transitionDuration}ms` : undefined
    }, viewportStyle);

    if (fillParent) {
      Object.assign(finalOuterStyle, fillStyle);
      Object.assign(finalViewportStyle, fillStyle);
    } // when not transitioning, render empty placeholder divs before the active view to push it into the right
    // horizontal position


    const views = [];

    for (let i = 0; i < (transitioning || keepViewsMounted ? numViews : activeView + 1); i++) {
      views[i] = this.renderView(i);
    }

    return React.createElement("div", {
      style: prefixer.prefix(finalOuterStyle),
      className: className,
      ref: this.rootRef
    }, React.createElement("div", {
      className: viewportClassName,
      style: prefixer.prefix(finalViewportStyle),
      ref: this.viewportRef,
      onTransitionEnd: this.onTransitionEnd
    }, views));
  }

}

exports.default = ViewSlider;